<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="twitter:card" content="summary_large_image" /><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Project | Lily</title>
<meta name="generator" content="Jekyll v4.1.1" />
<meta property="og:title" content="Project" />
<meta name="author" content="Lily Wu" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Songs" />
<meta property="og:description" content="Songs" />
<link rel="canonical" href="https://lwu1822.github.io/fastpages/misc/2023/05/31/CSAProject.html" />
<meta property="og:url" content="https://lwu1822.github.io/fastpages/misc/2023/05/31/CSAProject.html" />
<meta property="og:site_name" content="Lily" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2023-05-31T00:00:00-05:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Project" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Lily Wu"},"dateModified":"2023-05-31T00:00:00-05:00","datePublished":"2023-05-31T00:00:00-05:00","description":"Songs","headline":"Project","mainEntityOfPage":{"@type":"WebPage","@id":"https://lwu1822.github.io/fastpages/misc/2023/05/31/CSAProject.html"},"url":"https://lwu1822.github.io/fastpages/misc/2023/05/31/CSAProject.html"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/fastpages/assets/css/style.css"><link type="application/atom+xml" rel="alternate" href="https://lwu1822.github.io/fastpages/feed.xml" title="Lily" /><link rel="shortcut icon" type="image/x-icon" href="/fastpages/images/favicon.ico"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/Primer/15.2.0/primer.css" integrity="sha512-xTz2ys4coGAOz8vuV1NcQBkgVmKhsSEtjbqyMJbBHRplFuvKIUo6xhLHpAyPt9mfR6twHJgn9OgVLuqOvjeBhg==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.14.0/css/all.min.css" integrity="sha512-1PKOgIY59xJ8Co8+NE6FZ+LOAZKjy+KY8iq0G4B3CyeY6wYHN3yt9PW0XpSriVlkMXe40PTKnXrLnZ9+fkDaog==" crossorigin="anonymous" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.12.0/katex.min.css" integrity="sha512-h7nl+xz8wgDlNM4NqKEM4F1NkIRS17M9+uJwIGwuo8vGqIl4BhuCKdxjWEINm+xyrUjNCnK5dCrhM0sj+wTIXw==" crossorigin="anonymous" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.12.0/katex.min.js" integrity="sha512-/CMIhXiDA3m2c9kzRyd97MTb3MC6OVnx4TElQ7fkkoRghwDf6gi41gaT1PwF270W6+J60uTmwgeRpNpJdRV6sg==" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.12.0/contrib/auto-render.min.js" integrity="sha512-Do7uJAaHZm5OLrIv/yN4w0iG1dbu01kzdMNnFfu/mAqgUk6Nniv2JYHcwH+cNwjqgLcqcuBBk+JRvprLVI8azg==" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha512-0doc9hKxR3PYwso42RD1p5ySZpzzuDiOwMrdCEh2WdJZCjcmFKc/wEnL+z8fBQrnHoiNWbo+3fiGkOYXBdQp4A==" crossorigin="anonymous"></script>
    <script>
    document.addEventListener("DOMContentLoaded", function() {
        renderMathInElement( document.body, {
        delimiters: [
            {left: "$$", right: "$$", display: true},
            {left: "[%", right: "%]", display: true},
            {left: "$", right: "$", display: false}
        ]}
        );
    });
    </script>


<script>
function wrap_img(fn) {
    if (document.attachEvent ? document.readyState === "complete" : document.readyState !== "loading") {
        var elements = document.querySelectorAll(".post img");
        Array.prototype.forEach.call(elements, function(el, i) {
            if (el.getAttribute("title") && (el.className != "emoji")) {
                const caption = document.createElement('figcaption');
                var node = document.createTextNode(el.getAttribute("title"));
                caption.appendChild(node);
                const wrapper = document.createElement('figure');
                wrapper.className = 'image';
                el.parentNode.insertBefore(wrapper, el);
                el.parentNode.removeChild(el);
                wrapper.appendChild(el);
                wrapper.appendChild(caption);
            }
        });
    } else { document.addEventListener('DOMContentLoaded', fn); }
}
window.onload = wrap_img;
</script>

<script>
    document.addEventListener("DOMContentLoaded", function(){
    // add link icon to anchor tags
    var elem = document.querySelectorAll(".anchor-link")
    elem.forEach(e => (e.innerHTML = '<i class="fas fa-link fa-xs"></i>'));
    });
</script>
</head>
<body><header class="site-header">

  <div class="wrapper"><a class="site-title" rel="author" href="/fastpages/">Lily</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/fastpages/about/">About Me</a><a class="page-link" href="/fastpages/notes/">Notes</a><a class="page-link" href="/fastpages/weekly-work/">Weekly Work</a><a class="page-link" href="/fastpages/cb/">College Board</a><a class="page-link" href="/fastpages/class/">Other classes</a><a class="page-link" href="/fastpages/search/">Search</a><a class="page-link" href="/fastpages/categories/">Tags</a><a class="page-link" href="/fastpages/t/CSA">CSA</a><a class="page-link" href="/fastpages/CSP/">CSP</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Project</h1><p class="post-meta post-meta-title"><time class="dt-published" datetime="2023-05-31T00:00:00-05:00" itemprop="datePublished">
        May 31, 2023
      </time>• 
          <span itemprop="author" itemscope itemtype="http://schema.org/Person">
            <span class="p-author h-card" itemprop="name">Lily Wu</span></span>
       • <span class="read-time" title="Estimated read time">
    
    
      14 min read
    
</span></p>

    
      <p class="category-tags"><i class="fas fa-tags category-tags-icon"></i></i> 
      
        <a class="category-tags-link" href="/fastpages/categories/#misc">misc</a>
        
      
      </p>
    

    </header>

  <div class="post-content e-content" itemprop="articleBody">
    <ul id="toc" class="section-nav">
<li class="toc-entry toc-h1"><a href="#songs">Songs</a>
<ul>
<li class="toc-entry toc-h2"><a href="#overview">Overview</a></li>
<li class="toc-entry toc-h2"><a href="#introduction">Introduction</a></li>
<li class="toc-entry toc-h2"><a href="#reflection">Reflection</a></li>
<li class="toc-entry toc-h2"><a href="#moving-forward">Moving Forward</a></li>
<li class="toc-entry toc-h2"><a href="#the-code">The code</a>
<ul>
<li class="toc-entry toc-h3"><a href="#the-data">The data</a></li>
<li class="toc-entry toc-h3"><a href="#data-cleaning">Data cleaning</a></li>
<li class="toc-entry toc-h3"><a href="#overview-1">Overview</a></li>
<li class="toc-entry toc-h3"><a href="#common-variables">Common variables</a></li>
<li class="toc-entry toc-h3"><a href="#init">init</a></li>
<li class="toc-entry toc-h3"><a href="#constructor">Constructor</a></li>
</ul>
</li>
<li class="toc-entry toc-h2"><a href="#get_similar_itemsinput_song">get_similar_items(input_song)</a>
<ul>
<li class="toc-entry toc-h3"><a href="#construct_cooccurence_matrixinput_song-all_songs">construct_cooccurence_matrix(input_song, all_songs)</a></li>
<li class="toc-entry toc-h3"><a href="#generate_top_recommendations">generate_top_recommendations()</a></li>
</ul>
</li>
</ul>
</li>
</ul><h1 id="songs">
<a class="anchor" href="#songs" aria-hidden="true"><span class="octicon octicon-link"></span></a>Songs</h1>

<h2 id="overview">
<a class="anchor" href="#overview" aria-hidden="true"><span class="octicon octicon-link"></span></a>Overview</h2>

<p>The music recommender utilizes <strong>item-item collaborative filtering</strong> within <strong>collaborative based filtering</strong>. In other words, the program analyzes the music that users like. It then calculates a similarity score and populates it into a cooccurence matrix. The highest scores are obtained from the matrix, and the songs that they are associated with are the recommended songs.</p>

<h2 id="introduction">
<a class="anchor" href="#introduction" aria-hidden="true"><span class="octicon octicon-link"></span></a>Introduction</h2>

<p>To make the music recommender, there are two types of recommendation systems. The first is content based filtering, and the second is <strong>collaborative based filtering</strong>. The music recommender uses <strong>collaborative</strong> based filtering.</p>

<p>Collaborative based filtering consists of two parts:</p>

<ul>
  <li>Item-Item collaborative filtering</li>
  <li>User item collaborative filtering</li>
</ul>

<p>The music recommender uses <strong>item-item collaborative filtering</strong>. Item-item collaborative filtering will find items that a user liked based on other items that they like. In other words, it is “Users who liked this item also liked…”</p>

<p>Next, a cooccurrence matrix is created. What is a cooccurrence matrix? These are matrices found in item-item filtering. An example is this:</p>

<p><img src="/fastpages/images/cooMatrix.jpg" alt=""></p>

<p>Afterwards, we want to calculate the <strong>similarity</strong>. What is similarity? Going back to item-item collaborative filtering, it requires a user-item matrix to be created. In this case, the user is the user, while the item is the song. After a user-item matrix is created, the similarity can be calculated to create a similarity matrix.</p>

<p>In item-item filtering, the similarity includes 2 items, and many users (whereas in user-item filtering, the similarity includes 2 <em>users</em>, and many <em>items</em>).</p>

<p>Looks something like this:</p>

<p><img src="/fastpages/images/itemitemsimilarity.jpg" alt=""></p>

<h2 id="reflection">
<a class="anchor" href="#reflection" aria-hidden="true"><span class="octicon octicon-link"></span></a>Reflection</h2>

<p>One issue encountered was to achieve a balance between amount of data and the time that the program spends running. A larger dataset means that the recommendation would be more accurate; however, it would also take a lot of time. For example, using the current program, this line of code, <code class="language-plaintext highlighter-rouge">song_df = song_df.head(10000)</code> only considers the first 10000 songs in the dataset. Using 10000 songs, the program takes about 4.21 seconds to run:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># record time
</span><span class="n">startTime</span> <span class="o">=</span> <span class="n">time</span><span class="p">.</span><span class="n">time</span><span class="p">()</span>
<span class="n">init</span><span class="p">([</span><span class="s">"Hey_ Soul Sister"</span><span class="p">])</span>
<span class="k">print</span><span class="p">(</span><span class="s">"Total time elapsed: "</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">time</span><span class="p">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">startTime</span><span class="p">))</span>
</code></pre></div></div>

<p>Whereas increasing the program to use 50000 songs takes about 29.51 seconds. 100000 songs takes 67.23 seconds. 150000 songs took 72.41 seconds. 200000 songs took 98.10 seconds. As a result, we could only use a small portion of the dataset even when it had a lot more data (using 10000 songs out of a million songs).</p>

<p><img src="/fastpages/images/graph.jpg" alt=""></p>

<p>The pictures below demonstrate the precision-recall graph of the program:</p>

<p><img src="/fastpages/images/itemitem.jpg" alt="">
<img src="/fastpages/images/itemitem2.jpg" alt="">
<img src="/fastpages/images/itemitem5.jpg" alt=""></p>

<p>Specifically, precision and recall are utilized in binary classification algorithms. In the case of the music recommender, “binary” refers to whether the recommended song is correct or not.</p>

<p>What the precision-recall program does is that it splits the dataset into training data and testing data. It then finds the same songs found in both data, and selects a random sample from the data. Afterwards, for the training data, the program generates recommendations for each song found in the random sample. For the testing data, the program first locates the user that listened to the song in the sample. The program then finds other songs that the user listened to. This list of songs is used as the “actual” songs that the user likes. The program then compares the number of songs that match between the recommendations and the “actual” songs that the user likes. This number, along with other statistics, such as the length of the testing data, is used to calculate the precision and recall score.</p>

<p>A higher precision is better. The low score of our precision could be because the actual amount of songs that was used in the program was limited due to only selecting 10000 songs. Furthermore, the limitation could be due to the fact that we don’t actually have data about songs the user likes. The best we have is the number of songs that they listened to, and in this project, we assumed that that is the “actual” songs that the user likes.</p>

<p>Another limitation in our project is the dataset that we used. Our dataset came from Million Songs Dataset, which had enough data. However, the songs were pretty old (before 2010), so our program was limited to recommending pretty old songs.</p>

<h2 id="moving-forward">
<a class="anchor" href="#moving-forward" aria-hidden="true"><span class="octicon octicon-link"></span></a>Moving Forward</h2>

<p>There are a few solutions that I found through research to the limitations mentioned above. For better accuracy, collaborative filtering can be combined with content based filtering. Content based filtering utilizes information about the user to make recommendations (while collaborative uses other user’s preferences to make recommendations).</p>

<p>An interesting <a href="https://towardsdatascience.com/prototyping-a-recommender-system-step-by-step-part-2-alternating-least-square-als-matrix-4a76c58714a1">article</a> that I saw suggests alternating least squares as a better recommender system than collaborative filtering.</p>

<p>The article mentions three issues with collaborative filtering, which are the same issues that I found while making the music recommender. They are:</p>

<ul>
  <li>Item cold-start problem: Items with very little interactions that are used for recommendations are inaccurate</li>
  <li>Scalability issue: Hard to scale with large amounts of data</li>
</ul>

<p>The reason why I chose to use collaborative filtering was that it was easier to understand given that we had very little knowledge of machine learning before starting the project. Based on research, collaborative filtering is a basic recommendation system, so there are other, better systems (such as alternating least squares). However, collaborative filtering is one of the systems that websites such as Amazon and Netflix use for their recommendations, so it is still a system that is widely used.</p>

<h2 id="the-code">
<a class="anchor" href="#the-code" aria-hidden="true"><span class="octicon octicon-link"></span></a>The code</h2>

<p><a href="https://github.com/Lychee80/fourWsBackend/blob/main/Recommenders.py">Code file</a></p>

<h3 id="the-data">
<a class="anchor" href="#the-data" aria-hidden="true"><span class="octicon octicon-link"></span></a>The data</h3>

<p>The data comes from two datasets: <code class="language-plaintext highlighter-rouge">10000.txt</code> and <code class="language-plaintext highlighter-rouge">song_data.csv</code>. <code class="language-plaintext highlighter-rouge">10000.txt</code> contains the user id, song id, and number of times a user listened to a song. <code class="language-plaintext highlighter-rouge">song_data.csv</code> consists of the song id, song name (title), album name (release), artist’s name, and year.</p>

<p>The two datasets can be accessed <a href="https://www.kaggle.com/datasets/anuragbanerjee/million-song-data-set-subset">here</a>.</p>

<h3 id="data-cleaning">
<a class="anchor" href="#data-cleaning" aria-hidden="true"><span class="octicon octicon-link"></span></a>Data cleaning</h3>

<p>Throughout the code, there are lines that help filter the data. This is an important step in order to make sure that the data is clean so that the format is consistent throughout the entire file.</p>

<ul>
  <li>
    <p>Line (#):</p>

    <div class="language-plaintext highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>song_df_2 = song_df_2.drop_duplicates(['song_id'])
</code></pre></div>    </div>

    <p>This removes all duplicate song ids, ensuring that the file with the song info does not contain rows with duplicate songs.</p>
  </li>
</ul>

<h3 id="overview-1">
<a class="anchor" href="#overview-1" aria-hidden="true"><span class="octicon octicon-link"></span></a>Overview</h3>

<p>The main steps in the recommender is listed below. They can be found in the <code class="language-plaintext highlighter-rouge">init()</code> function.</p>

<ol>
  <li>Take the two datasets and combine them into one dataset.</li>
  <li>Take a subset of the dataset (ex: 10000 songs).</li>
  <li>Make an item similarity recommender
  a. Obtain unique songs from the training data</li>
</ol>

<p>b. Make a cooccurence matrix from the training data and populate it with similarity scores</p>

<p>c. Take the highest scores from the cooccurence matrix, locate the songs they correspond to, and output those songs</p>

<h3 id="common-variables">
<a class="anchor" href="#common-variables" aria-hidden="true"><span class="octicon octicon-link"></span></a>Common variables</h3>

<p>The code is quite long, so below are definitions of the commonly used variables in this program. These can be used to refer back to if you’re not sure what a certain variable stands for.</p>

<ul>
  <li>
    <p><code class="language-plaintext highlighter-rouge">input_song</code>: A list of songs that the user inputs. These are the songs that the user likes and wants to get recommendations for.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">all_songs</code>: A list of unique values in the training data under the <code class="language-plaintext highlighter-rouge">song</code> column.</p>
  </li>
</ul>

<h3 id="init">
<a class="anchor" href="#init" aria-hidden="true"><span class="octicon octicon-link"></span></a>init</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">init</span><span class="p">(</span><span class="n">input_song</span><span class="p">):</span>
    <span class="c1"># triplets_file consists of a "triplet" of data (user id, song id, listen count)
</span>    <span class="n">triplets_file</span> <span class="o">=</span> <span class="s">"data/test2/10000.txt"</span>
    <span class="n">songs_metadata_file</span> <span class="o">=</span> <span class="s">'data/test2/song_data.csv'</span>

    <span class="c1"># read table and define columns
</span>    <span class="n">song_df_1</span> <span class="o">=</span> <span class="n">pandas</span><span class="p">.</span><span class="n">read_table</span><span class="p">(</span><span class="n">triplets_file</span><span class="p">,</span><span class="n">header</span><span class="o">=</span><span class="bp">None</span><span class="p">)</span>
    <span class="n">song_df_1</span><span class="p">.</span><span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="s">'user_id'</span><span class="p">,</span> <span class="s">'song_id'</span><span class="p">,</span> <span class="s">'listen_count'</span><span class="p">]</span>

    <span class="c1"># read song metadata
</span>    <span class="n">song_df_2</span> <span class="o">=</span>  <span class="n">pandas</span><span class="p">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">songs_metadata_file</span><span class="p">)</span>
    <span class="c1"># clean data to remove rows with duplicate songs
</span>    <span class="n">song_df_2</span> <span class="o">=</span> <span class="n">song_df_2</span><span class="p">.</span><span class="n">drop_duplicates</span><span class="p">([</span><span class="s">'song_id'</span><span class="p">])</span>


    <span class="c1"># merge the two dataframes above to create input dataframe for recommender systems
</span>    <span class="c1"># keep the triplet data's song id, drop the duplicate column of "song_id" in the song data's file
</span>    <span class="n">song_df</span> <span class="o">=</span> <span class="n">pandas</span><span class="p">.</span><span class="n">merge</span><span class="p">(</span><span class="n">song_df_1</span><span class="p">,</span> <span class="n">song_df_2</span><span class="p">,</span> <span class="n">on</span><span class="o">=</span><span class="s">"song_id"</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s">"left"</span><span class="p">)</span> 

    <span class="c1"># subset consists of first 10000 songs
</span>    <span class="n">song_df</span> <span class="o">=</span> <span class="n">song_df</span><span class="p">.</span><span class="n">head</span><span class="p">(</span><span class="mi">10000</span><span class="p">)</span>

    
    <span class="n">song_df</span><span class="p">[</span><span class="s">'song'</span><span class="p">]</span> <span class="o">=</span> <span class="n">song_df</span><span class="p">[</span><span class="s">'title'</span><span class="p">].</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span> 

    <span class="c1"># alternatively, you can: 
</span>    <span class="c1"># merge song title and artist_name columns to make a merged column
</span>    <span class="c1"># because this recommender only recommends songs; we don't need artists
</span>    <span class="c1">#song_df['song'] = song_df['title'].map(str) + " - " + song_df['artist_name']
</span>    
    <span class="c1"># using scikit-learn to split data into training and testing data
</span>    <span class="c1"># test_size = 0.20: Testing size is 20% =&gt; training size is 80%
</span>    <span class="n">train_data</span><span class="p">,</span> <span class="n">test_data</span> <span class="o">=</span> <span class="n">train_test_split</span><span class="p">(</span><span class="n">song_df</span><span class="p">,</span> <span class="n">test_size</span> <span class="o">=</span> <span class="mf">0.20</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    
    <span class="c1"># make an item similarity recommender
</span>    <span class="n">is_model</span> <span class="o">=</span> <span class="n">item_similarity_recommender_py</span><span class="p">(</span><span class="n">train_data</span><span class="p">,</span> <span class="s">"user_id"</span><span class="p">,</span> <span class="s">"song"</span><span class="p">)</span>

    <span class="c1"># predict what song you would like based on a song that you input
</span>    <span class="n">df</span> <span class="o">=</span> <span class="n">is_model</span><span class="p">.</span><span class="n">get_similar_items</span><span class="p">(</span><span class="n">input_song</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">df</span>    
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">10000.txt</code> is read by Pandas into a dataframe, and assigned columns consisting of a user id, song id, and listen count. <code class="language-plaintext highlighter-rouge">song_data.csv</code> is also read by Pandas into a dataframe.</p>

<p>The next step is to combine the two datasets. However, notice how both <code class="language-plaintext highlighter-rouge">10000.txt</code> and <code class="language-plaintext highlighter-rouge">song_data.csv</code> includes the song id? If the two datasets were combined, they would have duplicate entries. Therefore, they merge on the <code class="language-plaintext highlighter-rouge">song_id</code> column, while keeping the first dataset’s <code class="language-plaintext highlighter-rouge">song_id</code> column.</p>

<p>The dataframe is then limited to the first 10000 songs. This number can be adjusted to be larger, which would probably provide more accurate results. However, this comes at the expense of taking more time to run the program.</p>

<p>Afterwards, the dataset is created with a <code class="language-plaintext highlighter-rouge">song</code> column. This column takes information from the title column. This is <strong>important because the title of the song is used when the user inputs a song name on the frontend and when the code outputs a song as recommendation.</strong></p>

<p>Alternatively, you can create a <code class="language-plaintext highlighter-rouge">song</code> column that consists of the combination of the <code class="language-plaintext highlighter-rouge">title</code> column and the <code class="language-plaintext highlighter-rouge">artist_name</code>. Therefore, the format of the data when being entered is <code class="language-plaintext highlighter-rouge">Song name - Artist name</code>.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># alternatively, you can: 
# merge song title and artist_name columns to make a merged column
# because this recommender only recommends songs; we don't need artists
</span><span class="n">song_df</span><span class="p">[</span><span class="s">'song'</span><span class="p">]</span> <span class="o">=</span> <span class="n">song_df</span><span class="p">[</span><span class="s">'title'</span><span class="p">].</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span> <span class="o">+</span> <span class="s">" - "</span> <span class="o">+</span> <span class="n">song_df</span><span class="p">[</span><span class="s">'artist_name'</span><span class="p">]</span>
</code></pre></div></div>

<p>After that, we want to split the dataset into testing and training data.</p>

<p><code>
train_data, test_data = train_test_split(song_df, test_size = 0.20, random_state=0)
</code></p>

<p>The testing and training data is useful for creating a precision-recall curve to determine the accuracy of the machine learning model.</p>

<p>This uses the <code class="language-plaintext highlighter-rouge">scikit-learn</code> library. In this case, the testing data’s size is 20% of the dataset, while the remaining 80% is the training data.</p>

<p>Next, the <code class="language-plaintext highlighter-rouge">init()</code> function creates an item similarity recommender using the training data. Finally, the program finds similar songs to the song that the user inputs.</p>

<h3 id="constructor">
<a class="anchor" href="#constructor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Constructor</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">is_model</span> <span class="o">=</span> <span class="n">item_similarity_recommender_py</span><span class="p">(</span><span class="n">train_data</span><span class="p">,</span> <span class="s">"user_id"</span><span class="p">,</span> <span class="s">"song"</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">train_data</span><span class="p">,</span> <span class="n">user_id</span><span class="p">,</span> <span class="n">item_id</span><span class="p">):</span>
    <span class="bp">self</span><span class="p">.</span><span class="n">train_data</span> <span class="o">=</span> <span class="n">train_data</span>
    <span class="bp">self</span><span class="p">.</span><span class="n">user_id</span> <span class="o">=</span> <span class="n">user_id</span>
    <span class="bp">self</span><span class="p">.</span><span class="n">item_id</span> <span class="o">=</span> <span class="n">item_id</span>
</code></pre></div></div>

<p>Since the code uses OOP, the class is called and the following variables are initialized:</p>
<ul>
  <li>
    <p>The training data (<code class="language-plaintext highlighter-rouge">train_data</code>).</p>
  </li>
  <li>
    <p>In addition, <code class="language-plaintext highlighter-rouge">user_id</code> is assigned to the string “user_id”, and <code class="language-plaintext highlighter-rouge">item_id</code> is assigned to the string “song”. Therefore, in this case, it is important to note that the <strong>item is the song</strong> (which makes sense because the recommendation really focuses on the user and their ratings for the songs).</p>
  </li>
</ul>

<h2 id="get_similar_itemsinput_song">
<a class="anchor" href="#get_similar_itemsinput_song" aria-hidden="true"><span class="octicon octicon-link"></span></a>get_similar_items(input_song)</h2>

<p>The next piece of code passes in a list of songs that the user inputs:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">df</span> <span class="o">=</span> <span class="n">is_model</span><span class="p">.</span><span class="n">get_similar_items</span><span class="p">(</span><span class="n">songList</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Get similar songs to those that the user inputs
</span><span class="k">def</span> <span class="nf">get_similar_items</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_song</span><span class="p">):</span>
    
    <span class="c1"># Obtain unique songs in the training data
</span>    <span class="n">all_songs</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">get_all_items_train_data</span><span class="p">()</span>
    
    <span class="k">print</span><span class="p">(</span><span class="s">"no. of unique songs in the training set: %d"</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">all_songs</span><span class="p">))</span>
        
    <span class="c1"># Make a cooccurence matrix
</span>    <span class="n">cooccurence_matrix</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">construct_cooccurence_matrix</span><span class="p">(</span><span class="n">input_song</span><span class="p">,</span> <span class="n">all_songs</span><span class="p">)</span>
    
    <span class="c1"># Use cooccurence matrix to generate recommendations 
</span>    <span class="n">user</span> <span class="o">=</span> <span class="s">""</span>
    <span class="n">df_recommendations</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">generate_top_recommendations</span><span class="p">(</span><span class="n">user</span><span class="p">,</span> <span class="n">cooccurence_matrix</span><span class="p">,</span> <span class="n">all_songs</span><span class="p">,</span> <span class="n">input_song</span><span class="p">)</span>
        
    <span class="k">return</span> <span class="n">df_recommendations</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">get_all_items_train_data()</code> is a function that returns a list of unique values in the training data under the <code class="language-plaintext highlighter-rouge">song</code> column. In other words, the function returns a list of unique songs in the training data.</p>

<p>Next, a cooccurrence matrix is created, which is then used to generate the recommendations.</p>

<h3 id="construct_cooccurence_matrixinput_song-all_songs">
<a class="anchor" href="#construct_cooccurence_matrixinput_song-all_songs" aria-hidden="true"><span class="octicon octicon-link"></span></a>construct_cooccurence_matrix(input_song, all_songs)</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Make a coocurrence matrix
</span><span class="k">def</span> <span class="nf">construct_cooccurence_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_song</span><span class="p">,</span> <span class="n">all_songs</span><span class="p">):</span>
        
    <span class="c1"># Obtain the user IDs of those who ranked songs that are the same as the songs that the user inputted 
</span>    <span class="n">user_songs_users</span> <span class="o">=</span> <span class="p">[]</span>        
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">input_song</span><span class="p">)):</span>
        <span class="n">user_songs_users</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">get_item_users</span><span class="p">(</span><span class="n">input_song</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
        
    <span class="c1"># Make a cooccurence matrix 
</span>    <span class="n">cooccurence_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">matrix</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">input_song</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">all_songs</span><span class="p">))),</span> <span class="nb">float</span><span class="p">)</span>
        
    <span class="c1"># Calculate similarity 
</span>    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">all_songs</span><span class="p">)):</span>
        <span class="c1"># Obtain a set of unique user IDs of those who listened to a song (song refers to the list of unique values in the training data under the song column)
</span>        <span class="n">songs_i_data</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">train_data</span><span class="p">[</span><span class="bp">self</span><span class="p">.</span><span class="n">train_data</span><span class="p">[</span><span class="bp">self</span><span class="p">.</span><span class="n">item_id</span><span class="p">]</span> <span class="o">==</span> <span class="n">all_songs</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
        <span class="n">users_i</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">songs_i_data</span><span class="p">[</span><span class="bp">self</span><span class="p">.</span><span class="n">user_id</span><span class="p">].</span><span class="n">unique</span><span class="p">())</span>
        
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">input_song</span><span class="p">)):</span>       
                
            <span class="c1"># Take a user ID from user_songs_users
</span>            <span class="n">users_j</span> <span class="o">=</span> <span class="n">user_songs_users</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                
            <span class="c1"># Compare the user ID from user_songs_users with the user IDs in the set
</span>            <span class="n">users_intersection</span> <span class="o">=</span> <span class="n">users_i</span><span class="p">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">users_j</span><span class="p">)</span>
            
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">users_intersection</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># Find the union of the two user IDs
</span>                <span class="n">users_union</span> <span class="o">=</span> <span class="n">users_i</span><span class="p">.</span><span class="n">union</span><span class="p">(</span><span class="n">users_j</span><span class="p">)</span>
                
                <span class="n">cooccurence_matrix</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">users_intersection</span><span class="p">))</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">users_union</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">cooccurence_matrix</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                
    
    <span class="k">return</span> <span class="n">cooccurence_matrix</span>
</code></pre></div></div>

<p>The program looks at the values under the <code class="language-plaintext highlighter-rouge">song</code> column in the training data. It first finds the values that match the songs that the user inputted (found in <code class="language-plaintext highlighter-rouge">input_song</code>). Then, the program adds the IDs of the users who ranked the songs into a list called <code class="language-plaintext highlighter-rouge">user_songs_users</code>.</p>

<p>Afterwards, a cooccurence matrix is created using numpy. The matrix originally consists of all zeros, and has a number of rows that is equal to the number of songs in <code class="language-plaintext highlighter-rouge">input_song</code>, and a number of columns that is equal to the number of songs in <code class="language-plaintext highlighter-rouge">all_songs</code> (a list of unique values in the training data under the <code class="language-plaintext highlighter-rouge">song</code> column).</p>

<p>Afterwards, we want to calculate <strong>simlarity</strong> by obtaining a set of unique user IDs of those who listened to a song and comparing it with the user IDs of those who listened to the songs that the user inputs.</p>

<p>Specifically, the code that calculates similarity does the following through iteration:</p>

<ol>
  <li>
    <p>It finds the rows in the dataset where the values under the <code class="language-plaintext highlighter-rouge">song</code> column in the training data match the name of a song in <code class="language-plaintext highlighter-rouge">all_songs</code> (the name depends on the value of <code class="language-plaintext highlighter-rouge">i</code> in the for loop, which determines the index of <code class="language-plaintext highlighter-rouge">all_songs</code>).</p>
  </li>
  <li>
    <p>A set of unique user IDs are obtained from the rows in step 1.</p>
  </li>
  <li>
    <p>The program uses a nested for loop for more iteration:</p>
  </li>
</ol>

<p>a. The code takes a user ID from <code class="language-plaintext highlighter-rouge">user_songs_users</code> and compares it with the user IDs in the set from step 2 (finding the <strong>intersection</strong>).</p>

<p>b. If there is a match, the union of the two user IDs from step 3a are recorded.</p>

<p>c. The quotient of the length of the intersection and the length of the union are added into the cooccurence matrix.</p>

<h3 id="generate_top_recommendations">
<a class="anchor" href="#generate_top_recommendations" aria-hidden="true"><span class="octicon octicon-link"></span></a>generate_top_recommendations()</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Use cooccurence matrix to generate recommendations 
</span><span class="k">def</span> <span class="nf">generate_top_recommendations</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">user</span><span class="p">,</span> <span class="n">cooccurence_matrix</span><span class="p">,</span> <span class="n">all_songs</span><span class="p">,</span> <span class="n">input_song</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="s">"Non zero values in cooccurence_matrix :%d"</span> <span class="o">%</span> <span class="n">np</span><span class="p">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="n">cooccurence_matrix</span><span class="p">))</span>
    
    
    <span class="c1"># Calculate a recommendation score
</span>    <span class="n">user_sim_scores</span> <span class="o">=</span> <span class="n">cooccurence_matrix</span><span class="p">.</span><span class="nb">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="n">cooccurence_matrix</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    
    <span class="n">user_sim_scores</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">array</span><span class="p">(</span><span class="n">user_sim_scores</span><span class="p">)[</span><span class="mi">0</span><span class="p">].</span><span class="n">tolist</span><span class="p">()</span>

    <span class="c1"># Sort the scores from highest to lowest
</span>    <span class="n">sort_index</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(((</span><span class="n">e</span><span class="p">,</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">e</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">user_sim_scores</span><span class="p">))),</span> <span class="n">reverse</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

    <span class="c1"># Make a new dataframe
</span>    <span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="s">'user_id'</span><span class="p">,</span> <span class="s">'song'</span><span class="p">,</span> <span class="s">'score'</span><span class="p">,</span> <span class="s">'rank'</span><span class="p">]</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">pandas</span><span class="p">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="n">columns</span><span class="p">)</span>
        
    <span class="c1"># Add top 10 highest scores to dataframe
</span>    <span class="n">rank</span> <span class="o">=</span> <span class="mi">1</span> 
    <span class="k">print</span><span class="p">(</span><span class="n">sort_index</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sort_index</span><span class="p">)):</span>
        <span class="k">if</span> <span class="o">~</span><span class="n">np</span><span class="p">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">sort_index</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="ow">and</span> <span class="n">all_songs</span><span class="p">[</span><span class="n">sort_index</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">input_song</span> <span class="ow">and</span> <span class="n">rank</span> <span class="o">&lt;=</span> <span class="mi">10</span><span class="p">:</span>
            <span class="n">df</span><span class="p">.</span><span class="n">loc</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">df</span><span class="p">)]</span><span class="o">=</span><span class="p">[</span><span class="n">user</span><span class="p">,</span><span class="n">all_songs</span><span class="p">[</span><span class="n">sort_index</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]],</span><span class="n">sort_index</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="n">rank</span><span class="p">]</span>
            <span class="n">rank</span> <span class="o">+=</span> <span class="mi">1</span>
    
    <span class="c1"># Error checking
</span>    <span class="k">if</span> <span class="n">df</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="s">"The current user has no songs for training the item similarity based recommendation model."</span><span class="p">)</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">df</span>
</code></pre></div></div>

<p>Using the cooccurence matrix, the recommendation score is calculated by dividing the sum of the values in each column with the number of rows. These scores are then converted to a list.</p>

<p>Using this list of scores, a new list is created that sorts the scores from highest to lowest and includes their corresponding index.</p>

<p>A new dataframe is then created that contains the user id, song, score, and rank.</p>

<p>The code then loops through the sorted list of scores and checks if the top values actually has a score and if these values are different from the song that the user inputs. Lastly, the dataframe adds in the name of the song (using the index in <code class="language-plaintext highlighter-rouge">sort_index</code> and locating it in <code class="language-plaintext highlighter-rouge">all_songs</code>), and its score.</p>


  </div><!-- from https://github.com/utterance/utterances -->
<script src="https://utteranc.es/client.js"
        repo="lwu1822/fastpages"
        issue-term="title"
        label="blogpost-comment"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script><a class="u-url" href="/fastpages/misc/2023/05/31/CSAProject.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/fastpages/"></data>

  <div class="wrapper">

    <div class="footer-col-wrapper">
      <div class="footer-col">
        <p class="feed-subscribe">
          <a href="https://lwu1822.github.io/fastpages/feed.xml">
            <svg class="svg-icon orange">
              <use xlink:href="/fastpages/assets/minima-social-icons.svg#rss"></use>
            </svg><span>Subscribe</span>
          </a>
        </p>
      </div>
      <div class="footer-col">
        <p>An easy to use blogging platform with support for Jupyter Notebooks.</p>
      </div>
    </div>

    <div class="social-links"><ul class="social-media-list"></ul>
</div>

  </div>

</footer>
</body>

</html>
